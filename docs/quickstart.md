# Quickstart

Interacting with **agemo** will always start by specifying a structured coalescent model for which you would want to obtain the generating function. Defining the structured coalescent model requires a sample configuration, and a list of events whenever there is more than one population from which samples have been drawn.

## sample configuration

The sample configuration should be a list containing a tuple for each of the populations that will be relevant during the coalescent history of the sample. For example, say two derived populations originated from a population split at some time point in the past, then you would have to provide an empty tuple representing that ancestral population.

```python
sample_configuration = [(, ), ('a', 'a'), ('b', 'b')]

```
In the example the first tuple represents the ancestral population not containing any lineages at the moment of sampling. Note that each sample should be represented using a single character.

## events

Secondly, a list containing all events relevant for the sample history should be compiled. See {class}`.Event`. Note that each event should be associated with a unique index ranging between the number of populations and (the number of populations $+$ the number of events). See {ref}`sec_array_indexing` on the why and how of using these indices.

Currently, the available models are limited to structured coalescent models with uni-directional migration and/or population splits.

## branchtypes

For a given sample configuration the set of possible branchtypes can be specified using {class}`.BranchTypeCounter`. Specify whether you want to take phase and/or root information into account. By default root and phase information are removed. In the absence of phase information you should label all samples within a single population with the same letter. In the absence of root information, the number of branchtypes will be halved, this is identical to folding when thinking about the site frequency spectrum.


## generating function

We can now finally determine the GF. This is done through an instance of {class}`.GfMatrixObject`.

```python
sample_configuration = [(, ), ('a', 'a'), ('b', 'b')]
btc = agemo.BranchTypeCounter(sample_configuration)
idx = len(sample_configuration)
events_list = [agemo.PopulationSplitEvent(idx, 0, 1, 2)]
gfObject = agemo.GfMatrixObject(btc, events_list)
```
From here we can use the {meth}`.GfMatrixObject.make_gf` method to generate the Laplace transform. The result is a list of lists as well as an equation_array. The list contains all paths through the coalescent state space graph, with each sublist representing a single path. Index $i$ within a sublist points at equation_array[$i$] which contains the coefficients representing equation $i$. See {ref}`sec_equation_array` on how to interpret these coefficients.

:::{note}
In case a discrete event was included, the equations generated by `.equations_from_matrix` still require taking an inverse Laplace transform with respect to the dummy variable representing the discrete event.
:::

:::{note}
In case you want to compute the ([bSFS](bSFS.md), there is no need to run {meth}`.GfMatrixObject.make_gf` first. The instance of {class}`.GfMatrixObject` can simply be passed as an argument to the {class}`.BSFSEvaluator`.
:::

(sec_equation_array)=
## equation array

The generating function in general will take the form of a sum of a product of factors $f[\boldsymbol{\omega}] = \frac{c}{\sum c_i\kappa_i + \sum l_j\lambda_j + \sum o_k \omega_k}$. In this equation, we associate a unique dummy variable with each of the branch types along which all of the competing processes happen. Roman letters represent integers counting the number of ways a certain (coalescence or other) event can take place ($c_i, l_j$) given the current state space, or the number of branches of a particular type ($o_i$). The Greek letters represent the rate of the associated competing processes.

Each factor in the GF can thus be encoded as a matrix with two rows containing the integer coefficients ($c$, $c_i, l_j, o_k$). The first row represents the numerator and will only contain a single non-zero value. The second row represents the denominator. Storing the equations in this way ensures that we can efficiently substitute in parameter values by taking the dot product with a vector representing a point in parameter space ($\kappa_i, \lambda_j, \omega_k$) (see {ref}`sec_array_indexing`).

A minimal representation of the GF therefore consists of the equation array containing all unique equations, and an array of arrays with equation indices describing all paths through the graph. 

(sec_array_indexing)=
## array indexing

Once the generating function has been determined, evaluating the GF will require a vector representing the rate of all the events that make up the structured coalescent model. Determining the position of each `float` value in the vector requires a bit of bookkeeping and is the reason why we require the user to provide a unique index for each specified event. 

As outline in {ref}`sec_equation_array`, the vector should be of the following form: $[c_0, ... c_i, l_0, ..., l_j, o_0, ..., o_k]$. With $c_i$ representing the coalenscent rate of population $i$, $l_j$ representing the rate of event $j$ and $o_k$ representing the mutation rate along branchtype $k$. The order of the coalescence rates is defined by the `sample_configuration` used to instantiate {class}`.BranchTypeCounter`, the order of the other events are the determined by the indices provided by the user. And the rest of the array should be populated by $\theta/2$, with $\theta$ the population-scaled mutation rate. The number of branchtypes for which to provide the mutation rate can be determined by running `len(BranchTypeCounter)`.

:::{note}
In case of a discrete event, the variable array should not contain an entry for the time to that discrete event. Instead a seperate time parameter should be provided. This means that the variable array should be of length `equation_array.shape[-1] - 1`.
:::

:::{note}
In the case of multiple populations, coalescence rates are relative and should be given relative to the rate in a reference population, i.e. $c_i = N_{e_{i}}/N_{e_{ref}}$. In case of a single population, $c_0 = 1$.
:::

(sec_bsfs_quickstart)=
### compute probabilities for bSFS

Computing the bSFS can be done for structured coalescent model with up to 1 discrete event. See section on [bSFS](bSFS.md).